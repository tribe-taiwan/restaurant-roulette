<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>滑動轉場效果測試</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://resource.trickle.so/vendor_lib/unpkg/react@18/umd/react.production.min.js"></script>
    <script src="https://resource.trickle.so/vendor_lib/unpkg/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://resource.trickle.so/vendor_lib/unpkg/@babel/standalone/babel.min.js"></script>
    
    <style>
        /* 滑動轉場動畫 */
        @keyframes slideInFromRight {
            0% {
                transform: translateX(100%);
            }
            100% {
                transform: translateX(0);
            }
        }

        @keyframes slideInFromLeft {
            0% {
                transform: translateX(-100%);
            }
            100% {
                transform: translateX(0);
            }
        }

        @keyframes slideOutToLeft {
            0% {
                transform: translateX(0);
            }
            100% {
                transform: translateX(-100%);
            }
        }

        @keyframes slideOutToRight {
            0% {
                transform: translateX(0);
            }
            100% {
                transform: translateX(100%);
            }
        }
    </style>
</head>
<body class="bg-gray-100 p-8">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useCallback, useRef, useEffect } = React;

        function SlideTransitionTest() {
            // 滑動轉場狀態
            const [isSliding, setIsSliding] = useState(false);
            const [currentImage, setCurrentImage] = useState(null);
            const [nextImage, setNextImage] = useState(null);
            const [slideDirection, setSlideDirection] = useState('left');

            // 測試圖片
            const testImages = [
                'https://picsum.photos/400/300?random=1',
                'https://picsum.photos/400/300?random=2',
                'https://picsum.photos/400/300?random=3',
                'https://picsum.photos/400/300?random=4',
                'https://picsum.photos/400/300?random=5'
            ];

            const [currentImageIndex, setCurrentImageIndex] = useState(0);
            const [displayImage, setDisplayImage] = useState(testImages[0]);

            // 預載入緩存池
            const [preloadedImages, setPreloadedImages] = useState(new Map());

            // 圖片預載入函數
            const preloadImage = (url) => {
                return new Promise((resolve, reject) => {
                    if (!url) {
                        resolve(null);
                        return;
                    }

                    const img = new Image();
                    img.onload = () => {
                        console.log('✅ 圖片預載入成功:', url);
                        resolve(img);
                    };
                    img.onerror = (error) => {
                        console.warn('⚠️ 圖片預載入失敗:', url, error);
                        reject(error);
                    };
                    img.src = url;

                    // 設置超時
                    setTimeout(() => {
                        reject(new Error('圖片載入超時'));
                    }, 5000);
                });
            };

            // 滑動窗口預載入管理
            const managePreloadWindow = useCallback(async (centerIndex) => {
                const windowSize = 5; // 預載入窗口大小
                const cleanupThreshold = 3; // 超過3張才清理

                console.log(`🔄 管理預載入窗口，中心索引: ${centerIndex}`);

                // 計算需要預載入的範圍
                const startIndex = Math.max(0, centerIndex - Math.floor(windowSize / 2));
                const endIndex = Math.min(testImages.length - 1, centerIndex + Math.floor(windowSize / 2));

                const newPreloadedImages = new Map(preloadedImages);

                // 預載入窗口內的圖片
                for (let i = startIndex; i <= endIndex; i++) {
                    const url = testImages[i];
                    if (!newPreloadedImages.has(url)) {
                        try {
                            console.log(`⏳ 預載入新圖片 [${i}]:`, url);
                            const img = await preloadImage(url);
                            newPreloadedImages.set(url, img);
                            console.log(`✅ 圖片 [${i}] 預載入完成`);
                        } catch (error) {
                            console.warn(`❌ 圖片 [${i}] 預載入失敗:`, error.message);
                        }
                    }
                }

                // 清理超出範圍的圖片（超過閾值才清理）
                const imagesToRemove = [];
                for (const [url] of newPreloadedImages) {
                    const imageIndex = testImages.indexOf(url);
                    if (imageIndex !== -1) {
                        const distance = Math.abs(imageIndex - centerIndex);
                        if (distance > Math.floor(windowSize / 2) + cleanupThreshold) {
                            imagesToRemove.push(url);
                        }
                    }
                }

                if (imagesToRemove.length > 0) {
                    console.log(`🧹 清理 ${imagesToRemove.length} 張超出範圍的圖片:`, imagesToRemove);
                    imagesToRemove.forEach(url => newPreloadedImages.delete(url));
                }

                setPreloadedImages(newPreloadedImages);
                console.log(`📊 預載入池狀態 - 大小: ${newPreloadedImages.size}, 窗口: [${startIndex}-${endIndex}]`);
            }, [preloadedImages, testImages]);

            // 初始預載入
            useEffect(() => {
                console.log('🚀 初始化預載入窗口...');
                managePreloadWindow(currentImageIndex);
            }, []);

            // 當圖片索引改變時更新預載入窗口（避免在滑動時干擾）
            useEffect(() => {
                if (!isSliding) {
                    console.log(`📋 索引變更觸發預載入管理: ${currentImageIndex}`);
                    managePreloadWindow(currentImageIndex);
                } else {
                    console.log(`⏸️ 滑動中，延遲預載入管理: ${currentImageIndex}`);
                    // 滑動結束後再執行預載入管理
                    const timer = setTimeout(() => {
                        if (!isSliding) {
                            console.log(`⏰ 延遲執行預載入管理: ${currentImageIndex}`);
                            managePreloadWindow(currentImageIndex);
                        }
                    }, 350); // 比滑動動畫稍長一點

                    return () => clearTimeout(timer);
                }
            }, [currentImageIndex, managePreloadWindow, isSliding]);

            // 滑動轉場函數（使用預載入緩存）
            const triggerSlideTransition = useCallback((newImageUrl, direction = 'left') => {
                if (isSliding) return;

                const currentImg = displayImage;
                const newImg = newImageUrl;

                // 檢查圖片是否已預載入
                if (preloadedImages.has(newImg)) {
                    console.log('🚀 使用預載入圖片，立即開始滑動:', newImg);
                } else {
                    console.log('⚠️ 圖片未預載入，但仍然開始滑動:', newImg);
                }

                setCurrentImage(currentImg);
                setNextImage(newImg);
                setSlideDirection(direction);
                setIsSliding(true);

                // 300ms後完成動畫並更新顯示圖片
                setTimeout(() => {
                    setIsSliding(false);
                    setCurrentImage(null);
                    setNextImage(null);
                    setDisplayImage(newImg);
                }, 300);
            }, [displayImage, isSliding, preloadedImages]);

            // 下一張圖片
            const goToNextImage = () => {
                const nextIndex = (currentImageIndex + 1) % testImages.length;
                console.log(`🎯 用戶點擊下一張: ${currentImageIndex} → ${nextIndex}`);

                // 先開始滑動動畫，避免被預載入過程干擾
                triggerSlideTransition(testImages[nextIndex], 'left');

                // 然後更新索引（這會觸發預載入，但不會影響當前動畫）
                setCurrentImageIndex(nextIndex);
            };

            // 上一張圖片
            const goToPrevImage = () => {
                const prevIndex = (currentImageIndex - 1 + testImages.length) % testImages.length;
                console.log(`🎯 用戶點擊上一張: ${currentImageIndex} → ${prevIndex}`);

                // 先開始滑動動畫，避免被預載入過程干擾
                triggerSlideTransition(testImages[prevIndex], 'right');

                // 然後更新索引（這會觸發預載入，但不會影響當前動畫）
                setCurrentImageIndex(prevIndex);
            };

            return (
                <div className="max-w-2xl mx-auto">
                    <h1 className="text-3xl font-bold text-center mb-8">滑動轉場效果測試</h1>
                    
                    {/* 圖片顯示區域 */}
                    <div className="relative w-full h-64 mb-6 rounded-lg overflow-hidden bg-gray-200">
                        {/* 滑動轉場容器 */}
                        {isSliding && (currentImage || nextImage) ? (
                            <div className="absolute inset-0 overflow-hidden">
                                {/* 當前圖片 - 滑出 */}
                                {currentImage && (
                                    <div
                                        className="absolute inset-0 w-full h-full"
                                        style={{
                                            backgroundImage: `url(${currentImage})`,
                                            backgroundSize: 'cover',
                                            backgroundPosition: 'center',
                                            transform: 'translateX(0)',
                                            animation: slideDirection === 'left' ? 'slideOutToLeft 300ms ease-out forwards' : 'slideOutToRight 300ms ease-out forwards',
                                            zIndex: 1
                                        }}
                                    />
                                )}
                                {/* 下一張圖片 - 從右側滑入 */}
                                {nextImage && (
                                    <div
                                        className="absolute inset-0 w-full h-full"
                                        style={{
                                            backgroundImage: `url(${nextImage})`,
                                            backgroundSize: 'cover',
                                            backgroundPosition: 'center',
                                            transform: slideDirection === 'left' ? 'translateX(100%)' : 'translateX(-100%)',
                                            animation: slideDirection === 'left' ? 'slideInFromRight 300ms ease-out forwards' : 'slideInFromLeft 300ms ease-out forwards',
                                            zIndex: 2
                                        }}
                                    />
                                )}
                            </div>
                        ) : (
                            /* 正常顯示狀態 */
                            <div 
                                className="absolute inset-0"
                                style={{
                                    backgroundImage: `url(${displayImage})`,
                                    backgroundSize: 'cover',
                                    backgroundPosition: 'center'
                                }}
                            />
                        )}

                        {/* 狀態指示器 */}
                        <div className="absolute top-4 left-4 bg-black bg-opacity-50 text-white px-3 py-1 rounded">
                            {isSliding ? '滑動中...' : `圖片 ${currentImageIndex + 1}/${testImages.length}`}
                        </div>

                        {/* 預載入狀態指示器 */}
                        <div className="absolute top-4 right-4 bg-blue-600 bg-opacity-80 text-white px-3 py-1 rounded text-sm">
                            預載入池: {preloadedImages.size}張
                        </div>

                        {/* 預載入詳細狀態 */}
                        <div className="absolute bottom-4 left-4 bg-green-600 bg-opacity-80 text-white px-3 py-1 rounded text-xs">
                            {preloadedImages.has(displayImage) ? '✅ 當前圖片已預載' : '⚠️ 當前圖片未預載'}
                        </div>
                    </div>
                    
                    {/* 控制按鈕 */}
                    <div className="flex justify-center gap-4">
                        <button
                            onClick={goToPrevImage}
                            disabled={isSliding}
                            className="px-6 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed"
                        >
                            ← 上一張
                        </button>
                        <button
                            onClick={goToNextImage}
                            disabled={isSliding}
                            className="px-6 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed"
                        >
                            下一張 →
                        </button>
                    </div>
                    
                    {/* 說明 */}
                    <div className="mt-8 p-4 bg-blue-50 rounded-lg">
                        <h3 className="font-bold mb-2">滑動窗口預載入測試：</h3>
                        <ul className="list-disc list-inside space-y-1 text-sm">
                            <li>點擊「下一張」按鈕測試左滑效果（新圖片從右側滑入）</li>
                            <li>點擊「上一張」按鈕測試右滑效果（新圖片從左側滑入）</li>
                            <li><strong>預載入策略</strong>：維持當前圖片前後各2張的預載入窗口（共5張）</li>
                            <li><strong>動態管理</strong>：切換圖片時自動預載入新範圍，超過8張距離才清理記憶體</li>
                            <li><strong>狀態顯示</strong>：右上角顯示預載入池大小，左下角顯示當前圖片狀態</li>
                            <li>動畫時長為 300ms，使用 ease-out 緩動函數</li>
                        </ul>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<SlideTransitionTest />, document.getElementById('root'));
    </script>
</body>
</html>
