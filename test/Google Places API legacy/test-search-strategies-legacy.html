<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é¤å»³æœç´¢ç­–ç•¥æ¸¬è©¦</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-section { border: 1px solid #ccc; margin: 20px 0; padding: 15px; }
        .result { background: #f5f5f5; padding: 10px; margin: 10px 0; }
        button { padding: 10px 20px; margin: 10px; }
        .restaurant-count { font-weight: bold; color: #d9534f; }
        .restaurant-list { max-height: 200px; overflow-y: auto; font-size: 12px; }
    </style>
</head>
<body>
    <h1>é¤å»³æœç´¢ç­–ç•¥æ¸¬è©¦</h1>
    
    <div class="test-section">
        <h2>æ¸¬è©¦ 1: éš¨æ©Ÿåç§»æœç´¢ä¸­å¿ƒé»</h2>
        <button onclick="testRandomOffset()">åŸ·è¡Œéš¨æ©Ÿåç§»æ¸¬è©¦</button>
        <div id="randomOffsetResult" class="result"></div>
    </div>

    <div class="test-section">
        <h2>æ¸¬è©¦ 2: æŒ‰è·¯åæœç´¢</h2>
        <button onclick="testStreetSearch()">åŸ·è¡Œè·¯åæœç´¢æ¸¬è©¦</button>
        <div id="streetSearchResult" class="result"></div>
    </div>

    <!-- è¼‰å…¥ä¸»é…ç½®æª”æ¡ˆä»¥ç²å– API KEY -->
    <script src="../utils/locationUtils.js"></script>
    <script>
        // æ¸¬è©¦ç”¨çš„å°å—ä½ç½®
        const testLocation = { lat: 22.9908, lng: 120.2133 }; // å°å—è»Šç«™é™„è¿‘
        
        // é‡å‘½åè®Šæ•¸é¿å…èˆ‡ locationUtils.js è¡çª
        let testPlacesService;
        let testGeocoder;

        // åˆå§‹åŒ– Google Maps æœå‹™
        function initServices() {
            // å‹•æ…‹è¼‰å…¥ Google Maps API
            if (!window.google) {
                const script = document.createElement('script');
                script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_PLACES_CONFIG.API_KEY}&libraries=places&callback=onGoogleMapsTestLoaded`;
                script.async = true;
                document.head.appendChild(script);
                return;
            }
            
            const mapDiv = document.createElement('div');
            mapDiv.style.display = 'none';
            document.body.appendChild(mapDiv);
            
            const testMap = new google.maps.Map(mapDiv, {
                center: testLocation,
                zoom: 15
            });
            
            testPlacesService = new google.maps.places.PlacesService(testMap);
            testGeocoder = new google.maps.Geocoder();
        }
        
        // Google Maps API è¼‰å…¥å®Œæˆå›èª¿
        window.onGoogleMapsTestLoaded = function() {
            console.log('âœ… Google Maps API è¼‰å…¥å®Œæˆ');
            
            const mapDiv = document.createElement('div');
            mapDiv.style.display = 'none';
            document.body.appendChild(mapDiv);
            
            const testMap = new google.maps.Map(mapDiv, {
                center: testLocation,
                zoom: 15
            });
            
            testPlacesService = new google.maps.places.PlacesService(testMap);
            testGeocoder = new google.maps.Geocoder();
        };

        // æ¸¬è©¦ 1: éš¨æ©Ÿåç§»æœç´¢
        async function testRandomOffset() {
            const resultDiv = document.getElementById('randomOffsetResult');
            resultDiv.innerHTML = '<p>ğŸ” åŸ·è¡Œéš¨æ©Ÿåç§»æœç´¢æ¸¬è©¦...</p>';
            
            if (!testPlacesService) {
                initServices();
                return;
            }
            
            const allRestaurants = new Set(); // ä½¿ç”¨ Set é¿å…é‡è¤‡
            const searchResults = [];
            
            // åŸ·è¡Œ 5 æ¬¡éš¨æ©Ÿåç§»æœç´¢
            for (let i = 0; i < 5; i++) {
                // éš¨æ©Ÿåç§» 500 ç±³
                const randomOffset = 0.005;
                const offsetLat = testLocation.lat + (Math.random() - 0.5) * randomOffset;
                const offsetLng = testLocation.lng + (Math.random() - 0.5) * randomOffset;
                const searchLocation = { lat: offsetLat, lng: offsetLng };
                
                console.log(`ğŸ² ç¬¬${i+1}æ¬¡éš¨æ©Ÿåç§»æœç´¢:`, searchLocation);
                
                try {
                    const restaurants = await searchNearbyWithTypes(searchLocation, ['restaurant', 'meal_takeaway']);
                    
                    restaurants.forEach(r => {
                        if (!allRestaurants.has(r.place_id)) {
                            allRestaurants.add(r.place_id);
                        }
                    });
                    
                    searchResults.push({
                        attempt: i + 1,
                        location: searchLocation,
                        count: restaurants.length,
                        restaurants: restaurants.map(r => r.name)
                    });
                    
                } catch (error) {
                    console.error(`âŒ ç¬¬${i+1}æ¬¡æœç´¢å¤±æ•—:`, error);
                }
            }
            
            // é¡¯ç¤ºçµæœ
            let html = `<h3>ğŸ² éš¨æ©Ÿåç§»æœç´¢çµæœ</h3>`;
            html += `<p class="restaurant-count">ç¸½è¨ˆæ‰¾åˆ° ${allRestaurants.size} å®¶ä¸é‡è¤‡é¤å»³</p>`;
            
            searchResults.forEach(result => {
                html += `<div style="border-left: 3px solid #007bff; padding-left: 10px; margin: 10px 0;">`;
                html += `<strong>ç¬¬${result.attempt}æ¬¡:</strong> æ‰¾åˆ° ${result.count} å®¶é¤å»³<br>`;
                html += `<small>ä½ç½®: ${result.location.lat.toFixed(4)}, ${result.location.lng.toFixed(4)}</small><br>`;
                html += `<div class="restaurant-list">${result.restaurants.join(', ')}</div>`;
                html += `</div>`;
            });
            
            resultDiv.innerHTML = html;
            
            console.log('ğŸ² éš¨æ©Ÿåç§»æœç´¢å®Œæˆï¼Œç¸½è¨ˆ:', allRestaurants.size, 'å®¶é¤å»³');
        }

        // æ¸¬è©¦ 2: æŒ‰è·¯åæœç´¢
        async function testStreetSearch() {
            const resultDiv = document.getElementById('streetSearchResult');
            resultDiv.innerHTML = '<p>ğŸ›£ï¸ åŸ·è¡Œè·¯åæœç´¢æ¸¬è©¦...</p>';
            
            if (!testPlacesService || !testGeocoder) {
                initServices();
                return;
            }
            
            // å‹•æ…‹ç²å–ç”¨æˆ¶ä½ç½®é™„è¿‘çš„é“è·¯
            const streets = await getNearbyStreets(testLocation);
            
            const allRestaurants = new Set();
            const searchResults = [];
            
            for (let i = 0; i < streets.length; i++) {
                const street = streets[i];
                console.log(`ğŸ›£ï¸ ç¬¬${i+1}æ¢è·¯æœç´¢: ${street}`);
                
                try {
                    // å…ˆç²å–è·¯åçš„åº§æ¨™
                    const location = await geocodeAddress(street);
                    
                    // åœ¨è©²ä½ç½®æœç´¢é¤å»³
                    const restaurants = await searchNearbyWithTypes(location, ['restaurant', 'meal_takeaway']);
                    
                    restaurants.forEach(r => {
                        if (!allRestaurants.has(r.place_id)) {
                            allRestaurants.add(r.place_id);
                        }
                    });
                    
                    searchResults.push({
                        street: street,
                        location: location,
                        count: restaurants.length,
                        restaurants: restaurants.map(r => r.name)
                    });
                    
                } catch (error) {
                    console.error(`âŒ ${street} æœç´¢å¤±æ•—:`, error);
                }
            }
            
            // é¡¯ç¤ºçµæœ
            let html = `<h3>ğŸ›£ï¸ è·¯åæœç´¢çµæœ</h3>`;
            html += `<p class="restaurant-count">ç¸½è¨ˆæ‰¾åˆ° ${allRestaurants.size} å®¶ä¸é‡è¤‡é¤å»³</p>`;
            
            searchResults.forEach(result => {
                html += `<div style="border-left: 3px solid #28a745; padding-left: 10px; margin: 10px 0;">`;
                html += `<strong>${result.street}:</strong> æ‰¾åˆ° ${result.count} å®¶é¤å»³<br>`;
                html += `<small>ä½ç½®: ${result.location.lat.toFixed(4)}, ${result.location.lng.toFixed(4)}</small><br>`;
                html += `<div class="restaurant-list">${result.restaurants.join(', ')}</div>`;
                html += `</div>`;
            });
            
            resultDiv.innerHTML = html;
            
            console.log('ğŸ›£ï¸ è·¯åæœç´¢å®Œæˆï¼Œç¸½è¨ˆ:', allRestaurants.size, 'å®¶é¤å»³');
        }

        // å‹•æ…‹ç²å–ç”¨æˆ¶ä½ç½®é™„è¿‘çš„é“è·¯
        async function getNearbyStreets(location) {
            try {
                // ä½¿ç”¨é€†åœ°ç†ç·¨ç¢¼ç²å–é™„è¿‘çš„åœ°å€ä¿¡æ¯
                const response = await new Promise((resolve, reject) => {
                    testGeocoder.geocode({ 
                        location: new google.maps.LatLng(location.lat, location.lng)
                    }, (results, status) => {
                        if (status === 'OK') {
                            resolve(results);
                        } else {
                            reject(new Error(`é€†åœ°ç†ç·¨ç¢¼å¤±æ•—: ${status}`));
                        }
                    });
                });

                // æå–åœ°å€çµ„ä»¶ï¼Œç”Ÿæˆé™„è¿‘è¡—é“åˆ—è¡¨
                const streets = [];
                const baseAddress = response[0];
                
                // å¾åœ°å€çµ„ä»¶ä¸­æå–åŸå¸‚å’Œå€åŸŸä¿¡æ¯
                let city = '';
                let area = '';
                let route = '';
                
                baseAddress.address_components.forEach(component => {
                    const types = component.types;
                    if (types.includes('administrative_area_level_2') || types.includes('locality')) {
                        city = component.long_name;
                    } else if (types.includes('administrative_area_level_3') || types.includes('sublocality_level_1')) {
                        area = component.long_name;
                    } else if (types.includes('route')) {
                        route = component.long_name;
                    }
                });

                // ç”Ÿæˆå¸¸è¦‹è¡—é“æ¨¡å¼ï¼ˆé©ç”¨æ–¼å…¨çƒï¼‰
                const streetPatterns = [
                    'Main Street', 'High Street', 'Park Avenue', 'Oak Street', 'Elm Street',
                    'First Avenue', 'Second Avenue', 'Market Street', 'Church Street', 'School Street'
                ];

                // å¦‚æœæœ‰å…·é«”çš„è·¯åï¼Œå„ªå…ˆä½¿ç”¨
                if (route) {
                    streets.push(`${route}, ${area || city}`);
                }

                // æ·»åŠ å‘¨é‚Šæ¨¡æ“¬æœç´¢é»ï¼ˆåŸºæ–¼è·é›¢åç§»ï¼‰
                const offsets = [
                    { lat: 0.01, lng: 0, name: 'North Area' },
                    { lat: -0.01, lng: 0, name: 'South Area' },
                    { lat: 0, lng: 0.01, name: 'East Area' },
                    { lat: 0, lng: -0.01, name: 'West Area' },
                    { lat: 0.007, lng: 0.007, name: 'Northeast Area' },
                    { lat: -0.007, lng: 0.007, name: 'Southeast Area' },
                    { lat: 0.007, lng: -0.007, name: 'Northwest Area' },
                    { lat: -0.007, lng: -0.007, name: 'Southwest Area' }
                ];

                // ç‚ºæ¯å€‹åç§»ä½ç½®ç”Ÿæˆæœç´¢åœ°å€
                for (const offset of offsets) {
                    const offsetLat = location.lat + offset.lat;
                    const offsetLng = location.lng + offset.lng;
                    
                    // ä½¿ç”¨åç§»å¾Œçš„åº§æ¨™ä½œç‚ºæœç´¢ä¸­å¿ƒ
                    streets.push({
                        name: `${offset.name} (${offsetLat.toFixed(4)}, ${offsetLng.toFixed(4)})`,
                        lat: offsetLat,
                        lng: offsetLng
                    });
                }

                console.log('ğŸ›£ï¸ ç”Ÿæˆçš„æœç´¢å€åŸŸ:', streets);
                return streets;

            } catch (error) {
                console.error('âŒ ç²å–é™„è¿‘è¡—é“å¤±æ•—:', error);
                
                // å›é€€æ–¹æ¡ˆï¼šä½¿ç”¨è·é›¢åç§»ç”Ÿæˆæœç´¢é»
                const fallbackStreets = [];
                const offsets = [
                    { lat: 0.01, lng: 0, name: 'North 1km' },
                    { lat: -0.01, lng: 0, name: 'South 1km' },
                    { lat: 0, lng: 0.01, name: 'East 1km' },
                    { lat: 0, lng: -0.01, name: 'West 1km' },
                    { lat: 0.005, lng: 0.005, name: 'Northeast 0.5km' },
                    { lat: -0.005, lng: 0.005, name: 'Southeast 0.5km' },
                    { lat: 0.005, lng: -0.005, name: 'Northwest 0.5km' },
                    { lat: -0.005, lng: -0.005, name: 'Southwest 0.5km' }
                ];

                offsets.forEach(offset => {
                    fallbackStreets.push({
                        name: offset.name,
                        lat: location.lat + offset.lat,
                        lng: location.lng + offset.lng
                    });
                });

                return fallbackStreets;
            }
        }

        // åœ°å€è½‰åº§æ¨™
        function geocodeAddress(address) {
            return new Promise((resolve, reject) => {
                // å¦‚æœ address æ˜¯ç‰©ä»¶ï¼ˆåŒ…å«åº§æ¨™ï¼‰ï¼Œç›´æ¥è¿”å›
                if (typeof address === 'object' && address.lat && address.lng) {
                    resolve(address);
                    return;
                }
                
                testGeocoder.geocode({ address: address }, (results, status) => {
                    if (status === 'OK' && results[0]) {
                        const location = results[0].geometry.location;
                        resolve({
                            lat: location.lat(),
                            lng: location.lng()
                        });
                    } else {
                        reject(new Error(`ç„¡æ³•æ‰¾åˆ°åœ°å€: ${address}`));
                    }
                });
            });
        }

        // åœ¨æŒ‡å®šä½ç½®æœç´¢å¤šç¨®é¡å‹çš„é¤å»³
        async function searchNearbyWithTypes(location, types) {
            const allRestaurants = [];
            
            for (const type of types) {
                try {
                    const restaurants = await searchNearby(location, type);
                    restaurants.forEach(r => {
                        if (!allRestaurants.find(existing => existing.place_id === r.place_id)) {
                            allRestaurants.push(r);
                        }
                    });
                } catch (error) {
                    console.warn(`âš ï¸ ${type} æœç´¢å¤±æ•—:`, error);
                }
            }
            
            return allRestaurants;
        }

        // åŸºæœ¬çš„ nearbySearch
        function searchNearby(location, type) {
            return new Promise((resolve, reject) => {
                const request = {
                    location: new google.maps.LatLng(location.lat, location.lng),
                    radius: 1000, // 1km æœç´¢ç¯„åœ
                    type: type
                };
                
                testPlacesService.nearbySearch(request, (results, status) => {
                    if (status === google.maps.places.PlacesServiceStatus.OK) {
                        resolve(results || []);
                    } else if (status === google.maps.places.PlacesServiceStatus.ZERO_RESULTS) {
                        resolve([]);
                    } else {
                        reject(new Error(`æœç´¢å¤±æ•—: ${status}`));
                    }
                });
            });
        }

        // é é¢è¼‰å…¥å¾Œåˆå§‹åŒ–
        window.onload = function() {
            console.log('ğŸš€ é¤å»³æœç´¢ç­–ç•¥æ¸¬è©¦é é¢å·²è¼‰å…¥');
            console.log('ğŸ“ æ¸¬è©¦ä½ç½®: å°å—è»Šç«™é™„è¿‘', testLocation);
        };
    </script>
</body>
</html>
